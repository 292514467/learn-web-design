<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>offsetLeft 和 offsetTop</title>
    <!--`offsetLeft`：当前元素相对于其**定位父元素**的水平偏移量。
        `offsetTop`：当前元素相对于其**定位父元素**的垂直偏移量。
        备注：从父亲的 padding 开始算起，父亲的 border 不算在内。 -->
    <style>
        .box1 {
            width: 300px;
            height: 300px;
            padding: 100px;
            margin: 100px;
            position: relative;
            border: 100px solid #000;
            background-color: pink;
        }

        .box2 {
            width: 100px;
            height: 100px;
            background-color: red;
            /*position: absolute;*/
            /*left: 10px;*/
            /*top: 10px;*/
        }
    </style>
</head>

<body>
    <div class="box1">
        <div class="box2" style="left: 10px;top: 20px"></div>
    </div>
    <script>
        var box2 = document.getElementsByClassName("box2")[0];

        //offsetTop和offsetLeft
        // 在父盒子有定位的情况下，offsetLeft == style.left(去掉px之后)。注意，后者style.left只识别行内样式。
        console.log(box2.offsetLeft);  //100
        console.log(box2.style.left);  //10px
        console.log(box2.offsetTop);  //100
        console.log(box2.style.top);  //20px

    </script>
    <!-- ### offsetLeft 和 style.left 区别
（1）最大区别在于：
offsetLeft 可以返回无定位父元素的偏移量。如果父元素中都没有定位，则body为准。
style.left 只能获取行内样式，如果父元素中都没有设置定位，则返回""（意思是，返回空字符串）;

（2）offsetTop 返回的是数字，而 style.top 返回的是字符串，而且还带有单位：px。
比如：
```javascript
div.offsetLeft = 100;
div.style.left = "100px";
```

（3）offsetLeft 和 offsetTop **只读**，而 style.left 和 style.top 可读写（只读是获取值，可写是修改值）

总结：我们一般的做法是：用offsetLeft 和 offsetTop 获取值，用style.left 和 style.top 赋值（比较方便）。理由如下：
- style.left：只能获取行内式，获取的值可能为空，容易出现NaN。
- offsetLeft：获取值特别方便，而且是现成的number，方便计算。它是只读的，不能赋值。 -->
</body>

</html>